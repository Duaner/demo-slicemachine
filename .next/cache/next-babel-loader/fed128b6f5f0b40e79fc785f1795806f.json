{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { query } from '../features/query';\nimport { registry as createRegistry } from '../features/registry';\nexport const useGetStaticProps = ({\n  uid,\n  lang,\n  params,\n  client,\n  body = 'body',\n  type = 'page',\n  queryType = 'repeat'\n}) => {\n  const apiParams = params || {\n    lang\n  };\n  return async function getStaticProps({\n    preview = null,\n    previewData = {},\n    params = {}\n  }) {\n    const registry = await createRegistry();\n    const {\n      ref = null\n    } = previewData;\n    const resolvedUid = typeof uid === 'function' ? uid({\n      params,\n      previewData,\n      preview\n    }) : uid || null;\n\n    try {\n      const doc = await query({\n        queryType,\n        apiParams: Object.assign({\n          ref\n        }, apiParams),\n        type,\n        uid: resolvedUid,\n        client\n      });\n      return {\n        props: _objectSpread(_objectSpread({}, doc), {}, {\n          error: null,\n          slices: doc ? doc.data[body] : [],\n          registry,\n          endpoint: client.api.url\n        })\n      };\n    } catch (e) {\n      if (true) {\n        console.error(`[next-slicezone] ${e.toString()}`);\n      }\n\n      return {\n        props: {\n          ref,\n          error: e.toString(),\n          uid: resolvedUid,\n          slices: [],\n          registry: null\n        }\n      };\n    }\n  };\n};","map":{"version":3,"sources":["/Users/renaudbressand/Work/an-awesome-next-app-this-is-like-the-1000-try/node_modules/next-slicezone/hooks/useGetStaticProps.js"],"names":["query","registry","createRegistry","useGetStaticProps","uid","lang","params","client","body","type","queryType","apiParams","getStaticProps","preview","previewData","ref","resolvedUid","doc","Object","assign","props","error","slices","data","endpoint","api","url","e","console","toString"],"mappings":";;;;;;AAAA,SAASA,KAAT,QAAsB,mBAAtB;AACA,SAASC,QAAQ,IAAIC,cAArB,QAA2C,sBAA3C;AAEA,OAAO,MAAMC,iBAAiB,GAAG,CAAC;AAChCC,EAAAA,GADgC;AAEhCC,EAAAA,IAFgC;AAGhCC,EAAAA,MAHgC;AAIhCC,EAAAA,MAJgC;AAKhCC,EAAAA,IAAI,GAAG,MALyB;AAMhCC,EAAAA,IAAI,GAAG,MANyB;AAOhCC,EAAAA,SAAS,GAAG;AAPoB,CAAD,KAQ3B;AACJ,QAAMC,SAAS,GAAGL,MAAM,IAAI;AAAED,IAAAA;AAAF,GAA5B;AAEA,SAAO,eAAeO,cAAf,CAA8B;AACnCC,IAAAA,OAAO,GAAG,IADyB;AAEnCC,IAAAA,WAAW,GAAG,EAFqB;AAGnCR,IAAAA,MAAM,GAAG;AAH0B,GAA9B,EAIJ;AAED,UAAML,QAAQ,GAAG,MAAMC,cAAc,EAArC;AAEA,UAAM;AAAEa,MAAAA,GAAG,GAAG;AAAR,QAAiBD,WAAvB;AACA,UAAME,WAAW,GAAG,OAAOZ,GAAP,KAAe,UAAf,GAA4BA,GAAG,CAAC;AAAEE,MAAAA,MAAF;AAAUQ,MAAAA,WAAV;AAAuBD,MAAAA;AAAvB,KAAD,CAA/B,GAAqET,GAAG,IAAI,IAAhG;;AACA,QAAI;AACF,YAAMa,GAAG,GAAG,MAAMjB,KAAK,CAAC;AACtBU,QAAAA,SADsB;AAEtBC,QAAAA,SAAS,EAAEO,MAAM,CAACC,MAAP,CAAc;AAAEJ,UAAAA;AAAF,SAAd,EAAuBJ,SAAvB,CAFW;AAGtBF,QAAAA,IAHsB;AAItBL,QAAAA,GAAG,EAAEY,WAJiB;AAKtBT,QAAAA;AALsB,OAAD,CAAvB;AAOA,aAAO;AACLa,QAAAA,KAAK,kCACAH,GADA;AAEHI,UAAAA,KAAK,EAAE,IAFJ;AAGHC,UAAAA,MAAM,EAAEL,GAAG,GAAGA,GAAG,CAACM,IAAJ,CAASf,IAAT,CAAH,GAAoB,EAH5B;AAIHP,UAAAA,QAJG;AAKHuB,UAAAA,QAAQ,EAAEjB,MAAM,CAACkB,GAAP,CAAWC;AALlB;AADA,OAAP;AAUD,KAlBD,CAkBE,OAAMC,CAAN,EAAS;AACT,gBAA2C;AACzCC,QAAAA,OAAO,CAACP,KAAR,CAAe,oBAAmBM,CAAC,CAACE,QAAF,EAAa,EAA/C;AACD;;AACD,aAAO;AACLT,QAAAA,KAAK,EAAE;AACLL,UAAAA,GADK;AAELM,UAAAA,KAAK,EAAEM,CAAC,CAACE,QAAF,EAFF;AAGLzB,UAAAA,GAAG,EAAEY,WAHA;AAILM,UAAAA,MAAM,EAAE,EAJH;AAKLrB,UAAAA,QAAQ,EAAE;AALL;AADF,OAAP;AASD;AACF,GA1CD;AA2CD,CAtDM","sourcesContent":["import { query } from '../features/query'\nimport { registry as createRegistry } from '../features/registry'\n\nexport const useGetStaticProps = ({\n  uid,\n  lang,\n  params,\n  client,\n  body = 'body',\n  type = 'page',\n  queryType = 'repeat',\n}) => {\n  const apiParams = params ||Â { lang }\n\n  return async function getStaticProps({\n    preview = null,\n    previewData = {},\n    params = {}\n  }) {\n\n    const registry = await createRegistry()\n\n    const { ref = null } = previewData\n    const resolvedUid = typeof uid === 'function' ? uid({ params, previewData, preview }) : (uid || null)\n    try {\n      const doc = await query({\n        queryType,\n        apiParams: Object.assign({ ref }, apiParams),\n        type,\n        uid: resolvedUid,\n        client,\n      })\n      return {\n        props: {\n          ...doc,\n          error: null,\n          slices: doc ? doc.data[body] : [],\n          registry,\n          endpoint: client.api.url\n        }\n      }\n\n    } catch(e) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.error(`[next-slicezone] ${e.toString()}`)\n      }\n      return {\n        props: {\n          ref,\n          error: e.toString(),\n          uid: resolvedUid,\n          slices: [],\n          registry: null\n        }\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}