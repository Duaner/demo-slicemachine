{"ast":null,"code":"import fs from 'fs';\nimport path from 'path';\nimport { SM_FILE } from 'sm-commons/consts';\nimport { getInfoFromPath as getLibraryInfo } from '../helper';\nimport { pascalize } from 'sm-commons/utils/str';\nconst ALL_KEY = '__allSlices';\n\nconst createImport = ({\n  isLocal,\n  name,\n  pathToSlices,\n  from\n}) => {\n  if (isLocal) {\n    return `import * as ${name} from '${pathToSlices}'\\n`;\n  }\n\n  return `import { Slices as ${name} } from '${from}'\\n`;\n};\n\nconst createDeclaration = libs => {\n  const imports = libs.reduce((acc, lib) => `${acc}${createImport(lib)}`, '');\n  const spread = `const ${ALL_KEY} = { ${libs.reverse().reduce((acc, {\n    name\n  }) => `${acc} ...${name},`, '')} }`;\n  return `${imports}\\n${spread}\\n`;\n};\n\nconst createBody = () => `const NotFound = ({ sliceName }) => {\n\tconsole.log(\\`[sm - resolver] component \"\\${sliceName}\" not found.\\`)\n\treturn process.env.NODE_ENV !== 'production' ? <p>component \"{sliceName}\" not found.</p> : <div />\n}\n\nexport default ({ sliceName, i }) => {\n\treturn ${ALL_KEY}[sliceName] ? ${ALL_KEY}[sliceName] : () => <NotFound sliceName={sliceName} />\n}\n`;\n\nasync function handleLibraryPath(libPath) {\n  const {\n    isLocal,\n    pathExists,\n    pathToSlices\n  } = await getLibraryInfo(libPath);\n\n  if (!pathExists) {\n    console.warn(`[next-slicezone] path to library \"${pathToSlices}\" does not exist. Skipping.`);\n    return null;\n  }\n\n  const from = isLocal ? libPath.slice(2) : libPath;\n  const endPathToSlices = `${isLocal ? './' : ''}${from}${pathToSlices.split(from).slice(1).join('')}`;\n  return {\n    isLocal,\n    from,\n    name: pascalize(from),\n    pathToSlices: endPathToSlices\n  };\n}\n\nexport const createResolver = async () => {\n  const pathToSmFile = path.posix.join(process.cwd(), SM_FILE);\n  const {\n    libraries\n  } = fs.existsSync(pathToSmFile) ? JSON.parse(fs.readFileSync(pathToSmFile)) : {};\n\n  if (!libraries) {\n    return console.warn(`[next-slicezone] expects a non-empty \"libraries\" array in file \"${SM_FILE}\"`);\n  }\n\n  if (!Array.isArray(libraries) || !libraries.length) {\n    return console.error('[next-slicezone] expects \"libraries\" option to be a non-empty array');\n  }\n\n  const librariesInfo = await Promise.all(libraries.map(async lib => await handleLibraryPath(lib)));\n  const declaration = createDeclaration(librariesInfo.filter(e => e));\n  const body = createBody();\n  const file = `${declaration}\n${body}\n  `;\n  return fs.writeFileSync(path.join(process.cwd(), 'sm-resolver.js'), file);\n};","map":{"version":3,"sources":["/Users/renaudbressand/Work/an-awesome-next-app-this-is-like-the-1000-try/node_modules/next-slicezone/features/components.js"],"names":["fs","path","SM_FILE","getInfoFromPath","getLibraryInfo","pascalize","ALL_KEY","createImport","isLocal","name","pathToSlices","from","createDeclaration","libs","imports","reduce","acc","lib","spread","reverse","createBody","handleLibraryPath","libPath","pathExists","console","warn","slice","endPathToSlices","split","join","createResolver","pathToSmFile","posix","process","cwd","libraries","existsSync","JSON","parse","readFileSync","Array","isArray","length","error","librariesInfo","Promise","all","map","declaration","filter","e","body","file","writeFileSync"],"mappings":"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","sourcesContent":["import fs from 'fs'\nimport path from 'path'\n\nimport { SM_FILE } from 'sm-commons/consts'\nimport { getInfoFromPath as getLibraryInfo } from '../helper'\nimport { pascalize } from 'sm-commons/utils/str'\n\n\nconst ALL_KEY = '__allSlices'\n\nconst createImport = ({ isLocal, name, pathToSlices, from }) => {\n  if (isLocal) {\n    return `import * as ${name} from '${pathToSlices}'\\n`\n  }\n  return `import { Slices as ${name} } from '${from}'\\n`\n}\n\nconst createDeclaration = (libs) => {\n  const imports = libs.reduce((acc, lib) => `${acc}${createImport(lib)}`, '')\n  const spread = `const ${ALL_KEY} = { ${libs.reverse().reduce((acc, { name }) => `${acc} ...${name},`, '')} }`\n  return `${imports}\\n${spread}\\n`\n}\n\nconst createBody = () =>\n`const NotFound = ({ sliceName }) => {\n\tconsole.log(\\`[sm - resolver] component \"\\${sliceName}\" not found.\\`)\n\treturn process.env.NODE_ENV !== 'production' ? <p>component \"{sliceName}\" not found.</p> : <div />\n}\n\nexport default ({ sliceName, i }) => {\n\treturn ${ALL_KEY}[sliceName] ? ${ALL_KEY}[sliceName] : () => <NotFound sliceName={sliceName} />\n}\n`\n\nasync function handleLibraryPath(libPath) {\n  const {\n    isLocal,\n    pathExists,\n    pathToSlices,\n  } = await getLibraryInfo(libPath)\n\n  if (!pathExists) {\n    console.warn(`[next-slicezone] path to library \"${pathToSlices}\" does not exist. Skipping.`)\n    return null\n  }\n\n  const from = isLocal ? libPath.slice(2) : libPath\n\n  const endPathToSlices = `${isLocal ? './' : ''}${from}${pathToSlices.split(from).slice(1).join('')}`\n\n  return {\n    isLocal,\n    from,\n    name: pascalize(from),\n    pathToSlices: endPathToSlices\n  }\n}\n\nexport const createResolver = async () => {\n  const pathToSmFile = path.posix.join(process.cwd(), SM_FILE)\n  const { libraries } = fs.existsSync(pathToSmFile) ? JSON.parse(fs.readFileSync(pathToSmFile)) : {}\n\n  if (!libraries) {\n    return console.warn(`[next-slicezone] expects a non-empty \"libraries\" array in file \"${SM_FILE}\"`)\n  }\n\n  if (!Array.isArray(libraries) || !libraries.length) {\n    return console.error('[next-slicezone] expects \"libraries\" option to be a non-empty array')\n  }\n\n  const librariesInfo = await Promise.all(libraries.map(async lib => await handleLibraryPath(lib)))\n  \n  const declaration = createDeclaration(librariesInfo.filter(e => e))\n\n  const body = createBody()\n\n  const file = \n  `${declaration}\n${body}\n  `\n  return fs.writeFileSync(path.join(process.cwd(), 'sm-resolver.js'), file);\n}"]},"metadata":{},"sourceType":"module"}