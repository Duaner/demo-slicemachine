{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport fs from 'fs';\nimport path from 'path';\nimport slash from 'slash';\nimport { SM_FILE } from 'sm-commons/consts';\nimport { getInfoFromPath as getLibraryInfo } from '../helper';\n\nfunction getComponentName(slicePath) {\n  const split = slicePath.split('/');\n  const pop = split.pop();\n\n  if (pop.indexOf('index.') === 0) {\n    return split.pop();\n  }\n\n  if (pop.indexOf(split[split.length - 1]) === 0) {\n    return slicePath.pop();\n  }\n\n  return pop.split('.')[0];\n}\n\nfunction matchPossiblePaths(files, componentName) {\n  const possiblePaths = ['index', componentName].reduce((acc, f) => [...acc, `${f}.vue`, `${f}.js`, `${f}.jsx`, `${f}.ts`, `${f}.tsx`], []);\n  return files.find(e => possiblePaths.indexOf(e) > -1);\n}\n\nfunction getFileInfoFromPath(slicePath, componentName) {\n  const isDirectory = fs.lstatSync(slicePath).isDirectory();\n\n  if (!isDirectory) {\n    return _objectSpread(_objectSpread({}, splitExtension(slicePath)), {}, {\n      isDirectory: false\n    });\n  }\n\n  const files = fs.readdirSync(slicePath);\n  const match = matchPossiblePaths(files, componentName);\n\n  if (match) {\n    return _objectSpread(_objectSpread({}, splitExtension(match)), {}, {\n      isDirectory: true\n    });\n  }\n\n  throw new Error(`[nuxt-sm] Could not find module file for component \"${componentName}\" at path \"${slicePath}\"`);\n}\n\nfunction getComponentInfo(slicePath) {\n  const name = getComponentName(slicePath);\n  const {\n    fileName,\n    extension,\n    isDirectory\n  } = getFileInfoFromPath(slicePath, name);\n  return {\n    name,\n    fileName,\n    isDirectory,\n    extension\n  };\n}\n\nfunction splitExtension(str) {\n  const fullName = str.split('/').pop();\n  const [fileName, extension] = fullName.split('.');\n  return {\n    fileName,\n    extension\n  };\n}\n\nasync function handleLibraryPath(libPath) {\n  const {\n    isLocal,\n    pathExists,\n    pathToSlices\n  } = await getLibraryInfo(libPath);\n\n  if (!pathExists) {\n    console.warn(`[next-slicezone] path to library \"${pathToSlices}\" does not exist. Skipping.`);\n    return {};\n  } // all paths to components found in slices folder\n\n\n  const pathsToComponents = fs.readdirSync(slash(pathToSlices)).map(curr => path.join(pathToSlices, curr)).filter(e => e.split('/').pop() !== 'index.js'); // library identifier\n\n  const from = isLocal ? libPath.slice(2) : libPath; // relative path to slice folder, to be appended with sliceName\n\n  const pathToSlice = `${isLocal ? './' : ''}${from}${pathToSlices.split(from).slice(1).join('')}`;\n  return pathsToComponents.reduce((acc, curr) => {\n    const {\n      name: sliceName,\n      fileName,\n      extension,\n      isDirectory\n    } = getComponentInfo(curr);\n    return _objectSpread(_objectSpread({}, acc), {}, {\n      [sliceName]: {\n        from,\n        sliceName,\n        pathToSlice,\n        extension,\n        fileName,\n        isDirectory\n      }\n    });\n  }, {});\n}\n\nexport async function registry(writeFile = false) {\n  const pathToSmFile = path.posix.join(process.cwd(), SM_FILE);\n  const {\n    libraries\n  } = fs.existsSync(pathToSmFile) ? JSON.parse(fs.readFileSync(pathToSmFile)) : {};\n\n  if (!libraries) {\n    return console.warn('[next-slicezone] expects a non-empty \"libraries\" array. If it was intended, consider removing the plugin from your config');\n  }\n\n  if (!Array.isArray(libraries) || !libraries.length) {\n    return console.error('[next-slicezone] expects \"libraries\" option to be a non-empty array');\n  }\n\n  const registries = await Promise.all(libraries.map(async lib => await handleLibraryPath(lib)));\n  const registry = registries.reduce((acc, curr) => _objectSpread(_objectSpread({}, curr), acc), {});\n  return registry;\n}","map":{"version":3,"sources":["/Users/renaudbressand/Work/an-awesome-next-app-this-is-like-the-1000-try/node_modules/next-slicezone/features/registry.js"],"names":["fs","path","slash","SM_FILE","getInfoFromPath","getLibraryInfo","getComponentName","slicePath","split","pop","indexOf","length","matchPossiblePaths","files","componentName","possiblePaths","reduce","acc","f","find","e","getFileInfoFromPath","isDirectory","lstatSync","splitExtension","readdirSync","match","Error","getComponentInfo","name","fileName","extension","str","fullName","handleLibraryPath","libPath","isLocal","pathExists","pathToSlices","console","warn","pathsToComponents","map","curr","join","filter","from","slice","pathToSlice","sliceName","registry","writeFile","pathToSmFile","posix","process","cwd","libraries","existsSync","JSON","parse","readFileSync","Array","isArray","error","registries","Promise","all","lib"],"mappings":"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","sourcesContent":["import fs from 'fs'\nimport path from 'path'\nimport slash from 'slash'\n\nimport { SM_FILE } from 'sm-commons/consts'\nimport { getInfoFromPath as getLibraryInfo } from '../helper'\n\nfunction getComponentName(slicePath) {\n  const split = slicePath.split('/');\n  const pop = split.pop();\n  if (pop.indexOf('index.') === 0) {\n    return split.pop();\n  }\n  if (pop.indexOf(split[split.length - 1]) === 0) {\n    return slicePath.pop();\n  }\n  return pop.split('.')[0];\n}\n\nfunction matchPossiblePaths(files, componentName) {\n  const possiblePaths = ['index', componentName]\n    .reduce((acc, f) => [...acc, `${f}.vue`, `${f}.js`, `${f}.jsx`, `${f}.ts`, `${f}.tsx`], [])\n  return files.find(e => possiblePaths.indexOf(e) > -1)\n}\n\nfunction getFileInfoFromPath(slicePath, componentName) {\n  const isDirectory = fs.lstatSync(slicePath).isDirectory()\n  if (!isDirectory) {\n    return { ...splitExtension(slicePath), isDirectory: false }\n  }\n\n  const files = fs.readdirSync(slicePath)\n  const match = matchPossiblePaths(files, componentName)\n  if (match) {\n    return { ...splitExtension(match), isDirectory: true };\n  }\n  throw new Error(`[nuxt-sm] Could not find module file for component \"${componentName}\" at path \"${slicePath}\"`)\n}\n\nfunction getComponentInfo(slicePath) {\n  const name = getComponentName(slicePath)\n  const { fileName, extension, isDirectory } = getFileInfoFromPath(slicePath, name)\n  return {\n    name,\n    fileName,\n    isDirectory,\n    extension\n  }\n\n}\n\nfunction splitExtension(str) {\n  const fullName = str.split('/').pop()\n  const [fileName, extension] = fullName.split('.')\n  return {\n    fileName,\n    extension,\n  }\n}\n\nasync function handleLibraryPath(libPath) {\n  const {\n    isLocal,\n    pathExists,\n    pathToSlices,\n  } = await getLibraryInfo(libPath)\n\n  if (!pathExists) {\n    console.warn(`[next-slicezone] path to library \"${pathToSlices}\" does not exist. Skipping.`)\n    return {}\n  }\n\n  // all paths to components found in slices folder\n  const pathsToComponents = fs.readdirSync(slash(pathToSlices))\n    .map(curr => path.join(pathToSlices, curr))\n    .filter(e => e.split('/').pop() !== 'index.js')\n\n  // library identifier\n  const from = isLocal ? libPath.slice(2) : libPath\n\n  // relative path to slice folder, to be appended with sliceName\n  const pathToSlice = `${isLocal ? './' : ''}${from}${pathToSlices.split(from).slice(1).join('')}`\n\n  return pathsToComponents.reduce(\n    (acc, curr) => {\n      const { name: sliceName, fileName, extension, isDirectory } = getComponentInfo(curr)\n      return {\n        ...acc,\n        [sliceName]: {\n          from,\n          sliceName,\n          pathToSlice,\n          extension,\n          fileName,\n          isDirectory\n        }\n      }\n    }, {}\n  );\n}\n\nexport async function registry(writeFile = false) {\n  const pathToSmFile = path.posix.join(process.cwd(), SM_FILE)\n  const { libraries } = fs.existsSync(pathToSmFile) ? JSON.parse(fs.readFileSync(pathToSmFile)) : {}\n\n  if (!libraries) {\n    return console.warn('[next-slicezone] expects a non-empty \"libraries\" array. If it was intended, consider removing the plugin from your config')\n  }\n\n  if (!Array.isArray(libraries) || !libraries.length) {\n    return console.error('[next-slicezone] expects \"libraries\" option to be a non-empty array')\n  }\n\n  const registries = await Promise.all(libraries.map(async lib => await handleLibraryPath(lib)))\n  const registry = registries.reduce((acc, curr) => ({ ...curr, ...acc }), {})\n  \n  return registry\n}"]},"metadata":{},"sourceType":"module"}