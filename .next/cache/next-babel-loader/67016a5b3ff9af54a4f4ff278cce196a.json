{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nasync function fetchDocs(client, params, page = 1, routes = []) {\n  const response = await client.query('', _objectSpread(_objectSpread({\n    pageSize: 100,\n    lang: '*'\n  }, params), {}, {\n    page\n  }));\n  const allRoutes = routes.concat(response.results);\n\n  if (response.results_size + routes.length < response.total_results_size) {\n    return fetchDocs(client, params, page + 1, allRoutes);\n  }\n\n  return [...new Set(allRoutes)];\n}\n\n;\n\nasync function queryRepeatableDocuments(client, params = {}, filter) {\n  const allRoutes = await fetchDocs(client, params);\n  return allRoutes.filter(filter);\n}\n\nexport const useGetStaticPaths = ({\n  type = 'page',\n  fallback = false,\n  formatPath = () => '/',\n  params,\n  lang,\n  client\n}) => {\n  const apiParams = params || {\n    lang\n  };\n  return async function getStaticPaths() {\n    const documents = await queryRepeatableDocuments(client, apiParams, doc => doc.type === type);\n    return {\n      paths: documents.map(formatPath),\n      fallback\n    };\n  };\n};","map":{"version":3,"sources":["/Users/renaudbressand/Work/an-awesome-next-app-this-is-like-the-1000-try/node_modules/next-slicezone/hooks/useGetStaticPaths.js"],"names":["fetchDocs","client","params","page","routes","response","query","pageSize","lang","allRoutes","concat","results","results_size","length","total_results_size","Set","queryRepeatableDocuments","filter","useGetStaticPaths","type","fallback","formatPath","apiParams","getStaticPaths","documents","doc","paths","map"],"mappings":";;;;;;AAAA,eAAeA,SAAf,CAAyBC,MAAzB,EAAiCC,MAAjC,EAAyCC,IAAI,GAAG,CAAhD,EAAmDC,MAAM,GAAG,EAA5D,EAAgE;AAC9D,QAAMC,QAAQ,GAAG,MAAMJ,MAAM,CAACK,KAAP,CAAa,EAAb;AAAmBC,IAAAA,QAAQ,EAAE,GAA7B;AAAkCC,IAAAA,IAAI,EAAE;AAAxC,KAAgDN,MAAhD;AAAwDC,IAAAA;AAAxD,KAAvB;AACA,QAAMM,SAAS,GAAGL,MAAM,CAACM,MAAP,CAAcL,QAAQ,CAACM,OAAvB,CAAlB;;AACA,MAAIN,QAAQ,CAACO,YAAT,GAAwBR,MAAM,CAACS,MAA/B,GAAwCR,QAAQ,CAACS,kBAArD,EAAyE;AACvE,WAAOd,SAAS,CAACC,MAAD,EAASC,MAAT,EAAiBC,IAAI,GAAG,CAAxB,EAA2BM,SAA3B,CAAhB;AACD;;AACD,SAAO,CAAC,GAAG,IAAIM,GAAJ,CAAQN,SAAR,CAAJ,CAAP;AACD;;AAAA;;AAED,eAAeO,wBAAf,CAAwCf,MAAxC,EAAgDC,MAAM,GAAG,EAAzD,EAA6De,MAA7D,EAAqE;AACnE,QAAMR,SAAS,GAAG,MAAMT,SAAS,CAACC,MAAD,EAASC,MAAT,CAAjC;AACA,SAAOO,SAAS,CAACQ,MAAV,CAAiBA,MAAjB,CAAP;AACD;;AAED,OAAO,MAAMC,iBAAiB,GAAG,CAAC;AAChCC,EAAAA,IAAI,GAAG,MADyB;AAEhCC,EAAAA,QAAQ,GAAG,KAFqB;AAGhCC,EAAAA,UAAU,GAAG,MAAM,GAHa;AAIhCnB,EAAAA,MAJgC;AAKhCM,EAAAA,IALgC;AAMhCP,EAAAA;AANgC,CAAD,KAO3B;AACJ,QAAMqB,SAAS,GAAGpB,MAAM,IAAI;AAAEM,IAAAA;AAAF,GAA5B;AAEA,SAAO,eAAee,cAAf,GAAgC;AACpC,UAAMC,SAAS,GAAG,MAAMR,wBAAwB,CAACf,MAAD,EAASqB,SAAT,EAAqBG,GAAD,IAASA,GAAG,CAACN,IAAJ,KAAaA,IAA1C,CAAhD;AACD,WAAO;AACLO,MAAAA,KAAK,EAAEF,SAAS,CAACG,GAAV,CAAcN,UAAd,CADF;AAELD,MAAAA;AAFK,KAAP;AAID,GAND;AAOD,CAjBM","sourcesContent":["async function fetchDocs(client, params, page = 1, routes = []) {\n  const response = await client.query('', { pageSize: 100, lang: '*', ...params, page });\n  const allRoutes = routes.concat(response.results);\n  if (response.results_size + routes.length < response.total_results_size) {\n    return fetchDocs(client, params, page + 1, allRoutes);\n  }\n  return [...new Set(allRoutes)];\n};\n\nasync function queryRepeatableDocuments(client, params = {}, filter) {\n  const allRoutes = await fetchDocs(client, params)\n  return allRoutes.filter(filter)\n}\n\nexport const useGetStaticPaths = ({\n  type = 'page',\n  fallback = false,\n  formatPath = () => '/',\n  params,\n  lang,\n  client\n}) => {\n  const apiParams = params ||Â { lang }\n\n  return async function getStaticPaths() {\n     const documents = await queryRepeatableDocuments(client, apiParams, (doc) => doc.type === type)\n    return {\n      paths: documents.map(formatPath),\n      fallback,\n    }\n  }\n}"]},"metadata":{},"sourceType":"module"}